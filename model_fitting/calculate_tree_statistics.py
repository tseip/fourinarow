from fourbynine import *
from parsers import parse_participant_file, parse_bads_parameter_file_to_model_parameters
import argparse
import random
from tqdm import tqdm
from ninarow_utilities import search_from_position


def sample_planning_depth(heuristic, positions, num_samples, disable_tqdm=True):
    """
    Given a heuristic and a list of positions, find the average planning depth
    for the heuristic across all of the positions. The planning depth is the
    average height of the search tree generated by the heuristic.

    Args:
        heuristic: The heuristic to use.
        positions: A list of positions to evaluate.
        num_samples: The number of samples to take in each position.
        disable_tqdm: If true, suppress TQDM command line output

    Returns:
        The average planning depth of the given heuristic across all given positions.
    """
    total_depth = 0
    for position in tqdm(positions, disable=disable_tqdm):
        for i in range(num_samples):
            total_depth += search_from_position(position,
                                                heuristic).get_depth_of_pv()
    return float(total_depth) / (len(positions) * num_samples)


def sample_average_branching_factor(heuristic, positions, num_samples, disable_tqdm=True):
    """
    Given a heuristic and a list of positions, find the average branching factor
    for the heuristic across all of the positions. The branching factor is the
    average number of children of nodes in the search tree generated by the heuristic.

    Args:
        heuristic: The heuristic to use.
        positions: A list of positions to evaluate.
        num_samples: The number of samples to take in each position.
        disable_tqdm: If true, suppress TQDM command line output

    Returns:
        The average branching factor of the given heuristic across all given positions.
    """
    total_branching_factor = 0.0
    for position in tqdm(positions, disable=disable_tqdm):
        for i in range(num_samples):
            total_branching_factor += search_from_position(
                position, heuristic).get_average_branching_factor()
    return float(total_branching_factor) / (len(positions) * num_samples)


def calculate_tree_statistics_from_file(path, heuristic, num_samples=10):
    """
    Given a file containing many positions, return some tree statistics across
    all positions in the file.

    Args:
        path: A path to the file to parse containing the positions.
        heuristic: The heuristic to use to evaluate the positions.
        num_samples: The number of samples to take at each position.
    """
    moves = parse_participant_file(path)
    positions = [move.board for move in moves]
    return sample_planning_depth(heuristic, positions, num_samples, False), sample_average_branching_factor(heuristic, positions, num_samples, False)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-f",
        "--participant_file",
        help="The file containing a list of positions to analyze.",
        required=True,
        type=str)
    parser.add_argument(
        "-p",
        "--params",
        help="The file containing the parameters for the model.",
        type=str)
    args = parser.parse_args()
    if args.params:
        params = parse_bads_parameter_file_to_model_parameters(args.params)
        heuristic = fourbynine_heuristic.create(DoubleVector(params), True)
    else:
        heuristic = fourbynine_heuristic.create()
    print("Average planning depth: {}, Average branching factor: {}".format(
        *calculate_tree_statistics_from_file(args.participant_file, heuristic)))


if __name__ == "__main__":
    main()
